using Assets.TValle.Tools.Runtime.Characters.Atts.Emotions;
using Assets.TValle.Tools.Runtime.Characters.Intections;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Assets.TValle.Tools.Runtime.Characters.Scenes
{

    public interface ISceneInteractions
    {
        /// <summary>
        /// When a new interaction arises between any characters,
        /// </summary>
        event OnCharactersInteractionHandler onInteraction;

        /// <summary>
        /// Interaction information is combined; this event is triggered when a new record is added or when it is altered by being combined.
        /// </summary>
        event OnRegisterChangedHandler onRegister;

        /// <summary>
        /// WILL clear the recorded interactions before storing new ones.
        /// </summary>
        void StartRecording();


        /// <summary>
        /// Get the interactions between two characters currently taking place.
        /// </summary>
        /// <param name="from">for now, always the male character</param>
        /// <param name="to">for now, always the female character</param>
        /// <returns></returns>
        ICharactersSceneInteractions GetTakingPlaceInteractions(SceneCharacter from, SceneCharacter to);
        /// <summary>
        /// Get the interactions between two characters currently taking place.
        /// </summary>
        /// <param name="from">for now, always the male character</param>
        /// <param name="to">for now, always the female character</param>
        /// <returns></returns>
        ICharactersSceneInteractions GetTakingPlaceInteractionsNotNull(SceneCharacter from, SceneCharacter to);


        /// <summary>
        /// Get the MAIN interactions between two characters so far. Taking Place Interactions will be ignored
        /// <para>MAIN means interactions that were not produced as a result of any other interaction, that is, by direct actions of the player</para>
        /// <para>USE THIS ONE, since the other two (GetSecondaryArchivedInteractions,GetMainAndSecondaryArchivedInteractions) may get obsolete
        /// </summary>        
        /// <param name="from">for now, always the male character</param>
        /// <param name="to">for now, always the female character</param>
        /// <returns></returns>
        ICharactersSceneInteractionsArchived GetMainArchivedInteractions(Guid from, Guid to);

        /// <summary>
        /// Get the SECONDARY interactions between two characters so far. Taking Place Interactions will be ignored
        /// <para>SECONDARY means interactions generated by other interactions.</para>
        /// </summary>        
        /// <param name="from">for now, always the male character</param>
        /// <param name="to">for now, always the female character</param>
        /// <returns></returns>
        ICharactersSceneInteractionsArchived GetSecondaryArchivedInteractions(Guid from, Guid to);

        /// <summary>
        /// Get the interactions between two characters so far. Taking Place Interactions will be ignored        
        /// </summary>        
        /// <param name="from">for now, always the male character</param>
        /// <param name="to">for now, always the female character</param>
        /// <returns></returns>
        ICharactersSceneInteractionsArchived GetMainAndSecondaryArchivedInteractions(Guid from, Guid to);
        
        /// <summary>
        /// Get the interactions between two characters so far. Taking Place Interactions will be ignored        
        /// </summary>        
        /// <param name="from">for now, always the male character</param>
        /// <param name="to">for now, always the female character</param>
        /// <returns></returns>
        ICharactersSceneInteractionsArchived GetMainAndSecondaryArchivedInteractionsNotNull(SceneCharacter from, SceneCharacter to);




        void EndRecordign();

        void Clear();

        /// <summary>
        /// Generates buffs and debuffs of characters "male" and "female" using the current scene interactions.
        /// </summary>
        void DefaultBuffAndDebuffGenerate(SceneCharacter male, SceneCharacter female, bool sceneAborted, DateTime now,
            out SceneCharacterFromToBuffAndDebuff maleBuffByInteractions, out SceneCharacterFromToBuffAndDebuff femaleBuffByInteractions);


        /// <summary>
        /// Generates buffs and debuffs of character "male" Only, using the current scene interactions.
        /// <para>use this if the female characters wont be in memory, if they are discarded</para>
        /// </summary>
        void DefaultBuffAndDebuffGenerate(SceneCharacter male, Guid female, bool sceneAborted, DateTime now,
            out SceneCharacterFromToBuffAndDebuff maleBuffByInteractions);

        /// <summary>
        /// Generates buffs and debuffs of character "female" Only, using the current scene interactions.
        /// <para>use this if the male characters wont be in memory, if they are discarded</para>
        /// </summary>
        void DefaultBuffAndDebuffGenerate(Guid male, SceneCharacter female, bool sceneAborted, DateTime now,
            out SceneCharacterFromToBuffAndDebuff femaleBuffByInteractions);

    }
    public delegate void OnInteractionHandler(ref Interaction newInteraction, ICharactersSceneInteractions sender);
    public delegate void OnInteractionStackHandler(ref Interaction stackedInteraction, ICharactersSceneInteractions sender);
    public delegate void OnCharactersInteractionHandler(ref Interaction newInteraction, ICharactersSceneInteractions Interactions, SceneCharacter from, SceneCharacter to, ISceneInteractions sender);
    public delegate void OnRegisterChangedHandler(ref Interaction register, ICharactersSceneInteractions Interactions, SceneCharacter from, SceneCharacter to, ISceneInteractions sender);

    /// <summary>
    /// no interaction on the same parts of the same type of the same emotion will be duplicated
    /// <para>EX: It will only record a single caress using the hand on her shoulder giving her pleasure; if there are multiple such events in the scene, it will combine them into one and calculate the total time by adding each individual interaction.</para>
    /// </summary>
    public interface ICharactersSceneInteractions
    {
        /// <summary>
        /// When a new interaction occurs
        /// </summary>
        event OnInteractionHandler onInteraction;
        /// <summary>
        /// Before adding the new interaction into the stacked interaction
        /// </summary>
        event OnInteractionStackHandler onStackingInteraction;
        /// <summary>
        /// After adding the new interaction into the stacked interaction
        /// </summary>
        event OnInteractionStackHandler onInteractionStacked;



        /// <summary>
        /// Get the interactions without emptying the interaction list.
        /// </summary>
        /// <returns>returns empty List  if not found</returns>
        IReadOnlyList<Interaction> Peek();

        /// <summary>
        /// Get the interaction without removing the interaction form the list
        /// </summary>     
        /// <param name="fromPart">The value cannot be equal to "All".</param>
        /// <param name="toPart">The value cannot be equal to "All".</param>
        /// <param name="interationReceivedType">The value cannot be equal to "All".</param>
        /// <param name="emotion">The value cannot be equal to "All".</param>
        /// <param name="reachedMaxValue">This should be true for interactions that cause the emotion to reach its maximum value.</param>
        /// <returns>returns invalid Interaction if not found</returns>
        void Peek(TriggeringBodyPart fromPart, SensitiveBodyPart toPart, InterationReceivedType interationReceivedType, Emotion emotion, bool reachedMaxValue, out Interaction interaction);



        [Obsolete("all interaction can be stacked into one now, no need for a list", true)]
        IReadOnlyList<Interaction> PeekMany(TriggeringBodyPart fromPart, SensitiveBodyPart toPart, InterationReceivedType interationReceivedType, Emotion emotion, bool reachedMaxValue);






        /// <summary>
        /// same to Peek, it returns Interaction.times
        /// </summary>
        int PeekTimes(TriggeringBodyPart fromPart, SensitiveBodyPart toPart, InterationReceivedType interationReceivedType, Emotion emotion, bool reachedMaxValue);
        /// <summary>
        /// same to Peek, it returns Interaction.IsValid
        /// </summary>
        bool PeekIsValid(TriggeringBodyPart fromPart, SensitiveBodyPart toPart, InterationReceivedType interationReceivedType, Emotion emotion, bool reachedMaxValue);
        /// <summary>
        /// same to Peek, it returns Interaction.endFrame
        /// </summary>
        int PeekEndFrame(TriggeringBodyPart fromPart, SensitiveBodyPart toPart, InterationReceivedType interationReceivedType, Emotion emotion, bool reachedMaxValue);
        int PeekStartFrame(TriggeringBodyPart fromPart, SensitiveBodyPart toPart, InterationReceivedType interationReceivedType, Emotion emotion, bool reachedMaxValue);

      



    }
    public class EmptyCharactersSceneInteractions : ICharactersSceneInteractions, ICharactersSceneInteractionsArchived
    {
        static EmptyCharactersSceneInteractions()
        {
            Instance = new EmptyCharactersSceneInteractions();
        }
        public static EmptyCharactersSceneInteractions Instance { get; private set; }


        private EmptyCharactersSceneInteractions()
        {
        }

        public event OnInteractionHandler onInteraction { add { } remove { } }
        public event OnInteractionStackHandler onStackingInteraction { add { } remove { } }
        public event OnInteractionStackHandler onInteractionStacked { add { } remove { } }

        public void Clear()
        {

        }

        public IReadOnlyList<Interaction> Peek()
        {
            return new List<Interaction>();
        }

        public void Peek(TriggeringBodyPart fromPart, SensitiveBodyPart toPart, InterationReceivedType interationReceivedType, Emotion emotion, bool reachedMaxValue, out Interaction interaction)
        {
            interaction = default;
        }

        public void PeekEmotionDamagePair(Emotion main, EmotionPercentageRange mainRange, Emotion secondary, EmotionPercentageRange secondaryRange, out EmotionDamagePair emotionDamagePair)
        {
            emotionDamagePair = default;
        }

        public int PeekEndFrame(TriggeringBodyPart fromPart, SensitiveBodyPart toPart, InterationReceivedType interationReceivedType, Emotion emotion, bool reachedMaxValue)
        {
            return 0;
        }

        public bool PeekIsValid(TriggeringBodyPart fromPart, SensitiveBodyPart toPart, InterationReceivedType interationReceivedType, Emotion emotion, bool reachedMaxValue)
        {
            return false;
        }

        public IReadOnlyList<Interaction> PeekMany(TriggeringBodyPart fromPart, SensitiveBodyPart toPart, InterationReceivedType interationReceivedType, Emotion emotion, bool reachedMaxValue)
        {
            return new List<Interaction>();
        }

        public int PeekStartFrame(TriggeringBodyPart fromPart, SensitiveBodyPart toPart, InterationReceivedType interationReceivedType, Emotion emotion, bool reachedMaxValue)
        {
            return 0;
        }

        public int PeekTimes(TriggeringBodyPart fromPart, SensitiveBodyPart toPart, InterationReceivedType interationReceivedType, Emotion emotion, bool reachedMaxValue)
        {
            return 0;
        }

        public int PeekTriggeringBodyPartCount(SensitiveBodyPart toPart, InterationReceivedType interationReceivedType, Emotion emotion, bool reachedMaxValue)
        {
            return 0;
        }

        public int PeekSensitiveBodyPartCount(TriggeringBodyPart fromPart, InterationReceivedType interationReceivedType, Emotion emotion, bool reachedMaxValue)
        {
            return 0;
        }

        public int PeekInterationReceivedTypeCount(TriggeringBodyPart fromPart, SensitiveBodyPart toPart, Emotion emotion, bool reachedMaxValue)
        {
            return 0;
        }

        public int PeekEmotionCount(TriggeringBodyPart fromPart, SensitiveBodyPart toPart, InterationReceivedType interationReceivedType, bool reachedMaxValue)
        {
            return 0;
        }
    }
    /// <summary>
    /// no interaction on the same parts of the same type of the same emotion will be duplicated
    /// <para>EX: It will only record a single caress using the hand on her shoulder giving her pleasure; if there are multiple such events in the scene, it will combine them into one and calculate the total time by adding each individual interaction.</para>
    /// </summary>
    public interface ICharactersSceneInteractionsClearable : ICharactersSceneInteractions
    {



        /// <summary>
        /// empty the interaction list
        /// </summary>
        void Clear();
    }
    public interface ICharactersSceneInteractionsArchived : ICharactersSceneInteractionsClearable
    {
        void PeekEmotionDamagePair(Emotion main, EmotionPercentageRange mainRange, Emotion secondary, EmotionPercentageRange secondaryRange, out EmotionDamagePair emotionDamagePair);
        
        
        int PeekTriggeringBodyPartCount(SensitiveBodyPart toPart, InterationReceivedType interationReceivedType, Emotion emotion, bool reachedMaxValue);
        int PeekSensitiveBodyPartCount(TriggeringBodyPart fromPart, InterationReceivedType interationReceivedType, Emotion emotion, bool reachedMaxValue);
        int PeekInterationReceivedTypeCount(TriggeringBodyPart fromPart, SensitiveBodyPart toPart, Emotion emotion, bool reachedMaxValue);
        int PeekEmotionCount(TriggeringBodyPart fromPart, SensitiveBodyPart toPart, InterationReceivedType interationReceivedType, bool reachedMaxValue);
    }
}
